# Tarantool Lua Debugger for Visual Studio Code

A simple Tarantool Lua debugger which requires no additional dependencies.

---
## Notice of Breaking Change
Beginning in version 0.3.0, projects which use sourcemaps to debug code transpiled from another language (such as TypescriptToLua), **must** specify the [`scriptFiles`](#scriptFiles) launch configuration option in order to use breakpoints in the original source files. This allows these to be resolved at startup instead of at runtime which allows for a significant performance increase.

---
## Features
- Debug Lua using Tarantool
- Basic debugging features (stepping, inspecting, breakpoints, etc...)
- Conditional breakpoints
- Debug coroutines as separate threads
- Basic support for source maps, such as those generated by [TypescriptToLua](https://typescripttolua.github.io/)

---
## Usage

### Tarantool Lua Interpreter
To debug a Lua program using particular Tarantool executable, set `lua-tarantool.tarantool` in your user or workspace settings.

Alternatively, you can set the interpreter and file to run in `launch.json`:
```json
{
  "configurations": [
    {
      "type": "lua-tarantool",
      "request": "launch",
      "name": "Debug",
      "program": {
        "tarantool": "<path to tarantool executable>",
        "file": "${file}"
      }
    }
  ]
}
```
---
## Requirements & Limitations
- The Lua environment must support communication via either stdio or pipes.
  - Some environments may require command line options to support stdio communication (ex. Solar2D requires `/no-console` flag)
  - Use of `io.read` or other calls that require user input will cause problems in stdio mode. Set [`program.communication`](#program.communication) to `pipe` to work around this.
- The Lua environment must be built with the `debug` library, and no other code should attempt to set debug hooks.
- You cannot manually pause debugging while the program is running.
- In Lua 5.1 and LuaJIT, the main thread cannot be accessed while stopped inside of a coroutine.

---

Note that the path to `lldebugger` will automatically be appended to the `LUA_PATH` environment variable, so it can be found by Lua.

---
## Tips
- For convenience, a global reference to the debugger is always stored as `lldebugger`.
- You can detect that the debugger extension is attached by inspecting the environment variable `LOCAL_LUA_DEBUGGER_VSCODE`. This is useful for conditionally starting the debugger in custom environments.
    ```lua
    if os.getenv("LOCAL_LUA_DEBUGGER_VSCODE") == "1" then
      require("lldebugger").start()
    end
    ```
- Some custom environments will not break on uncaught runtime errors. To catch a runtime error, you can wrap the code with `lldebugger.call()`:
    ```lua
    lldebugger.call(function()
    --code causing runtime error
    end)
    ```
- Some environments will not load required files from the standard filesystem. In these cases, you may be able to load the debugger manually using the file path stored in `LOCAL_LUA_DEBUGGER_FILEPATH`:
    ```lua
    package.loaded["lldebugger"] = assert(loadfile(os.getenv("LOCAL_LUA_DEBUGGER_FILEPATH")))()
    require("lldebugger").start()
    ```

---
## Additional Configuration Options
#### `scriptRoots`

A list of alternate paths to find Lua scripts. This is useful for environments like LÃ–VE, which use custom resolvers to find scripts in other locations than what is in `package.config`.

#### `scriptFiles`

A list of glob patterns identifying where to find Lua scripts in the workspace when debugging. This is required for placing breakpoints in sourcemapped files (ex. 'ts' scripts when using TypescriptToLua), as the source files must be looked up ahead of time so that breakpoints can be resolved.

Example: `scriptFiles: ["**/*.lua"]`

#### `ignorePatterns`

A list of [Lua patterns](https://www.lua.org/manual/5.4/manual.html#6.4.1) that specifies files to skip when stepping through code.

Example: `ignorePatterns: ["^/usr"]`

#### `stepUnmappedLines`

Step into Lua when stepping through source-mapped code and no mapping is available for the current line.

#### `breakInCoroutines`

Break into the debugger when errors occur inside coroutines.
- Coroutines created with `coroutine.wrap` will always break, regardless of this option.
- In Lua 5.1, this will break where the coroutine was resumed and the message will contain the actual location of the error.

#### `stopOnEntry`

Automatically break on first line after debug hook is set.

#### `cwd`

Specify working directory to launch executable in. Default is the project directory.

#### `args`

List of arguments to pass to Lua script or custom environment when launching.

#### `env`

Specify environment variables to set when launching executable.

#### `program.communication`

Specifies how the extension communicates with the debugger.

Possible values:
- `stdio` (default): Messages are embeded in stdin and stdout.
- `pipe`: Pipes are created for passing messages (named pipes on Windows, fifos on Linux). Use this if your environment has issues with stdio communication.

#### `verbose`

Enable verbose output from debugger. Only useful when trying to identify problems with the debugger itself.
